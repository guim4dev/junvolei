# PRD v0.3 ‚Äî Game Improvements

**Produto:** Simulador de Futev√¥lei 3D no Browser  
**Codinome:** JunVolei  
**Vers√£o:** v0.3 (Melhorias de Gameplay)  
**Status:** PRONTO PARA IMPLEMENTA√á√ÉO  
**Baseado em:** Feedback de playtesting v0.2

---

## 1. Resumo das Mudan√ßas

| #   | Mudan√ßa                              | Tipo      | Prioridade |
| --- | ------------------------------------ | --------- | ---------- |
| 1   | Regra de toques correta (futev√¥lei)  | Mec√¢nica  | Cr√≠tica    |
| 2   | Controle de for√ßa e dire√ß√£o          | UX        | Alta       |
| 3   | Nova bola estilo Mikasa              | Visual    | M√©dia      |
| 4   | Saque direto para oponentes          | Mec√¢nica  | Alta       |
| 5   | Saque do lado correto (n√£o central)  | Mec√¢nica  | Alta       |

---

## 2. Detalhamento das Mudan√ßas

### 2.1 Regra de Toques Correta (Futev√¥lei)

**Problema:** Atualmente n√£o h√° controle adequado de toques alternados entre jogadores.

**Regras oficiais do futev√¥lei:**

```
REGRAS DE TOQUES:
‚îú‚îÄ‚îÄ M√°ximo de 3 toques por time antes de devolver
‚îú‚îÄ‚îÄ M√≠nimo de 1 toque (pode atacar direto)
‚îú‚îÄ‚îÄ Um jogador N√ÉO pode tocar 2 vezes seguidas
‚îú‚îÄ‚îÄ Toques devem ALTERNAR entre parceiros
‚îî‚îÄ‚îÄ Se A toca, pr√≥ximo toque deve ser B (ou devolu√ß√£o)

EXEMPLOS V√ÅLIDOS:
‚úì Jogador A recebe ‚Üí Jogador B levanta ‚Üí Jogador A ataca (3 toques)
‚úì Jogador A recebe ‚Üí Jogador A ataca (INV√ÅLIDO - mesmo jogador)
‚úì Jogador A recebe ‚Üí Jogador B ataca (2 toques) 
‚úì Jogador A ataca direto (1 toque)

EXEMPLOS INV√ÅLIDOS:
‚úó Jogador A toca ‚Üí Jogador A toca novamente (mesmo jogador seguido)
‚úó 4 ou mais toques
‚úó Jogador A ‚Üí B ‚Üí A ‚Üí B (4 toques)
```

**Implementa√ß√£o:**

```typescript
// ScoreSystem.ts - melhorado
export class ScoreSystem {
  private touchCount: number = 0;
  private lastTouchPlayerId: string | null = null;
  private currentTeam: "player" | "opponent" | null = null;

  public registerTouch(playerId: string, team: "player" | "opponent"): boolean {
    // Se mudou de time, resetar contagem
    if (this.currentTeam !== team) {
      this.touchCount = 0;
      this.lastTouchPlayerId = null;
      this.currentTeam = team;
    }

    // Verificar se mesmo jogador tocou 2x seguidas (FALTA!)
    if (this.lastTouchPlayerId === playerId) {
      console.log("FALTA: Mesmo jogador tocou 2x seguidas!");
      return false; // Retorna false = falta
    }

    // Incrementar toques
    this.touchCount++;
    this.lastTouchPlayerId = playerId;

    // Verificar se passou de 3 toques (FALTA!)
    if (this.touchCount > 3) {
      console.log("FALTA: Mais de 3 toques!");
      return false;
    }

    return true; // Toque v√°lido
  }

  public resetRally() {
    this.touchCount = 0;
    this.lastTouchPlayerId = null;
    this.currentTeam = null;
  }
}
```

**Arquivos afetados:**

- `src/systems/ScoreSystem.ts` ‚Äî l√≥gica de toques
- `src/entities/Player.ts` ‚Äî passar ID √∫nico ao tocar
- `src/entities/NPC.ts` ‚Äî passar ID √∫nico ao tocar

---

### 2.2 Controle de For√ßa e Dire√ß√£o

**Problema:** Atualmente chute e cabeceio t√™m for√ßa e dire√ß√£o fixas, sem controle do jogador.

**Solu√ß√£o:** Ao pressionar o bot√£o de a√ß√£o, mostrar um sistema de mira + medidor de for√ßa.

**Interface proposta:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                      ‚îÇ
‚îÇ                    [JOGO]                           ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ                      ‚Üë                              ‚îÇ
‚îÇ                   ‚ï±     ‚ï≤                           ‚îÇ
‚îÇ                 ‚Üê    ‚óè    ‚Üí   ‚Üê Seta de dire√ß√£o    ‚îÇ
‚îÇ                   ‚ï≤     ‚ï±       (gira com drag)    ‚îÇ
‚îÇ                      ‚Üì                              ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ   [JOYSTICK]                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ                                   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚îÇ ‚Üê Barra  ‚îÇ
‚îÇ                                   ‚îÇ‚ñà‚ñà‚ñà‚ñà‚ñà‚îÇ   de     ‚îÇ
‚îÇ                                   ‚îÇ‚ñà‚ñà‚ñà  ‚îÇ   for√ßa  ‚îÇ
‚îÇ                                   ‚îÇ     ‚îÇ   (sobe  ‚îÇ
‚îÇ                                   ‚îÇ     ‚îÇ   e      ‚îÇ
‚îÇ                                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   desce) ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ                         [KICK]  [HEAD]              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Fluxo de uso:**

1. **Pressionar e segurar** o bot√£o KICK ou HEAD
2. **Aparece:** Indicador de dire√ß√£o (seta ao redor do jogador)
3. **Arrastar:** Muda a dire√ß√£o do chute/cabeceio (360¬∞)
4. **Medidor de for√ßa:** Barra que oscila automaticamente (0% ‚Üí 100% ‚Üí 0% ‚Üí ...)
5. **Soltar:** Executa a√ß√£o com a for√ßa do momento + dire√ß√£o escolhida

**Comportamento do medidor de for√ßa:**

```typescript
// PowerMeter - oscila continuamente enquanto bot√£o pressionado
class PowerMeter {
  private power: number = 0;
  private direction: number = 1; // 1 = subindo, -1 = descendo
  private speed: number = 2.5; // Ciclos por segundo
  private isActive: boolean = false;

  public start() {
    this.isActive = true;
    this.power = 0;
    this.direction = 1;
  }

  public update(deltaTime: number): number {
    if (!this.isActive) return 0;

    // Oscila entre 0 e 1
    this.power += this.direction * this.speed * deltaTime;

    if (this.power >= 1) {
      this.power = 1;
      this.direction = -1;
    } else if (this.power <= 0) {
      this.power = 0;
      this.direction = 1;
    }

    return this.power;
  }

  public stop(): number {
    this.isActive = false;
    return this.power; // Retorna for√ßa no momento do release
  }
}
```

**Controle de dire√ß√£o (arrastar):**

```typescript
// DirectionControl - arrastar para escolher dire√ß√£o
class DirectionControl {
  private angle: number = 0; // Radianos, 0 = frente
  private isActive: boolean = false;
  private startTouch: { x: number; y: number } | null = null;

  public start(touchX: number, touchY: number) {
    this.isActive = true;
    this.startTouch = { x: touchX, y: touchY };
    this.angle = 0; // Default: para frente
  }

  public update(touchX: number, touchY: number) {
    if (!this.isActive || !this.startTouch) return;

    const dx = touchX - this.startTouch.x;
    const dy = touchY - this.startTouch.y;

    // S√≥ atualiza se arrastou o suficiente
    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
      this.angle = Math.atan2(dx, -dy); // Convertido para coordenadas do jogo
    }
  }

  public getDirection(): THREE.Vector3 {
    // Converter √¢ngulo para vetor 3D
    // angle = 0 ‚Üí frente (Z negativo para advers√°rio)
    // angle = PI/2 ‚Üí direita
    // angle = -PI/2 ‚Üí esquerda
    return new THREE.Vector3(
      Math.sin(this.angle), // X
      0.5, // Y (sempre um pouco pra cima)
      -Math.cos(this.angle) // Z (negativo = lado advers√°rio)
    ).normalize();
  }

  public stop() {
    this.isActive = false;
    this.startTouch = null;
  }
}
```

**Visual do indicador de dire√ß√£o:**

```typescript
// Criar seta 3D que rotaciona ao redor do jogador
class DirectionIndicator {
  private arrow: THREE.Mesh;
  private ring: THREE.Mesh;

  constructor(scene: THREE.Scene) {
    // C√≠rculo base (mostra √°rea de alcance)
    const ringGeometry = new THREE.RingGeometry(1.5, 1.7, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      opacity: 0.3,
      transparent: true,
      side: THREE.DoubleSide,
    });
    this.ring = new THREE.Mesh(ringGeometry, ringMaterial);
    this.ring.rotation.x = -Math.PI / 2; // Horizontal

    // Seta de dire√ß√£o
    const arrowShape = new THREE.Shape();
    arrowShape.moveTo(0, 0.5);
    arrowShape.lineTo(0.3, 0);
    arrowShape.lineTo(0, -0.5);
    arrowShape.lineTo(-0.3, 0);
    arrowShape.closePath();

    const arrowGeometry = new THREE.ShapeGeometry(arrowShape);
    const arrowMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      opacity: 0.8,
      transparent: true,
    });
    this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);

    scene.add(this.ring);
    scene.add(this.arrow);
    this.hide();
  }

  public show(position: THREE.Vector3, angle: number) {
    this.ring.position.copy(position);
    this.ring.position.y = 0.1; // Ligeiramente acima do ch√£o

    // Posicionar seta na borda do c√≠rculo
    const arrowDistance = 1.6;
    this.arrow.position.set(
      position.x + Math.sin(angle) * arrowDistance,
      0.5,
      position.z - Math.cos(angle) * arrowDistance
    );
    this.arrow.rotation.z = -angle;

    this.ring.visible = true;
    this.arrow.visible = true;
  }

  public hide() {
    this.ring.visible = false;
    this.arrow.visible = false;
  }
}
```

**UI do medidor de for√ßa (HTML overlay):**

```typescript
// PowerMeterUI - barra visual que oscila
class PowerMeterUI {
  private container: HTMLDivElement;
  private bar: HTMLDivElement;
  private fill: HTMLDivElement;

  constructor() {
    this.container = document.createElement("div");
    this.container.style.cssText = `
      position: fixed;
      bottom: 200px;
      right: 30px;
      width: 30px;
      height: 150px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid white;
      border-radius: 5px;
      display: none;
      z-index: 1001;
    `;

    this.fill = document.createElement("div");
    this.fill.style.cssText = `
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
      border-radius: 3px;
      transition: height 0.05s linear;
    `;

    this.container.appendChild(this.fill);
    document.body.appendChild(this.container);
  }

  public show() {
    this.container.style.display = "block";
  }

  public hide() {
    this.container.style.display = "none";
  }

  public update(power: number) {
    // power: 0 a 1
    this.fill.style.height = `${power * 100}%`;

    // Mudar cor baseado na for√ßa
    if (power < 0.3) {
      this.fill.style.background = "#00ff00"; // Verde (fraco)
    } else if (power < 0.7) {
      this.fill.style.background = "#ffff00"; // Amarelo (m√©dio)
    } else {
      this.fill.style.background = "#ff6600"; // Laranja (forte)
    }
  }
}
```

**Arquivos afetados:**

- Novo: `src/controls/PowerMeter.ts`
- Novo: `src/controls/DirectionControl.ts`
- Novo: `src/ui/DirectionIndicator.ts`
- Novo: `src/ui/PowerMeterUI.ts`
- `src/controls/TouchControls.ts` ‚Äî integrar novos controles
- `src/entities/Player.ts` ‚Äî usar for√ßa e dire√ß√£o vari√°veis

---

### 2.3 Nova Bola Estilo Mikasa

**Problema:** A bola com losangos n√£o representa bem uma bola de futev√¥lei.

**Solu√ß√£o:** Criar padr√£o de pent√°gonos amarelos e tri√¢ngulos pretos, similar √† bola Mikasa FT-5.

**Refer√™ncia visual (bola Mikasa):**

```
       ‚ï±‚ï≤
      ‚ï±  ‚ï≤
     ‚ï± ‚ñ≤  ‚ï≤
    ‚ï±‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï≤
   ‚îÇ ‚¨†    ‚¨† ‚îÇ   ‚Üê Pent√°gonos amarelos
    ‚ï≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï±
     ‚ï≤ ‚ñº  ‚ï±      ‚Üê Tri√¢ngulos pretos
      ‚ï≤  ‚ï±
       ‚ï≤‚ï±
```

**Especifica√ß√µes:**

- **Padr√£o:** Icosaedro truncado (como bola de futebol cl√°ssica)
- **Pent√°gonos:** Amarelo dourado (#FFD700)
- **Tri√¢ngulos/Hex√°gonos:** Preto (#000000)
- **Costuras:** Linhas brancas entre as formas

**Novo tamanho da bola:**

```typescript
// constants.ts
BALL_RADIUS: 0.45  // Aumentado de 0.35 para 0.45
                   // Di√¢metro: 0.9 unidades
                   // Bem vis√≠vel na tela
```

**Implementa√ß√£o da textura:**

```typescript
// Ball.ts - textura estilo Mikasa
private createMikasaTexture(): THREE.CanvasTexture {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext("2d")!;

  // Fundo base amarelo dourado
  ctx.fillStyle = "#FFD700";
  ctx.fillRect(0, 0, 512, 512);

  // Padr√£o de hex√°gonos/pent√°gonos pretos
  ctx.fillStyle = "#000000";
  ctx.strokeStyle = "#FFFFFF";
  ctx.lineWidth = 3;

  // Criar padr√£o de colmeia (aproxima√ß√£o do padr√£o de bola)
  const hexSize = 60;
  const rows = 10;
  const cols = 10;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const x = col * hexSize * 1.5 + (row % 2) * hexSize * 0.75;
      const y = row * hexSize * 0.866;

      // Alternar entre preto e amarelo
      if ((row + col) % 3 === 0) {
        this.drawHexagon(ctx, x, y, hexSize * 0.4, true); // Preto preenchido
      }
    }
  }

  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  return texture;
}

private drawHexagon(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  size: number,
  fill: boolean
) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 3) * i - Math.PI / 6;
    const px = x + size * Math.cos(angle);
    const py = y + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();

  if (fill) {
    ctx.fill();
  }
  ctx.stroke();
}
```

**Alternativa: Usar geometria IcosahedronGeometry**

```typescript
// Criar bola com faces coloridas individualmente
const geometry = new THREE.IcosahedronGeometry(GAME_CONFIG.BALL_RADIUS, 1);

// Colorir faces alternadamente
const colors = [];
const color1 = new THREE.Color(0xffd700); // Amarelo
const color2 = new THREE.Color(0x000000); // Preto

for (let i = 0; i < geometry.attributes.position.count; i++) {
  const faceIndex = Math.floor(i / 3);
  const color = faceIndex % 3 === 0 ? color2 : color1;
  colors.push(color.r, color.g, color.b);
}

geometry.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

const material = new THREE.MeshStandardMaterial({
  vertexColors: true,
  roughness: 0.4,
  metalness: 0.1,
});
```

**Arquivos afetados:**

- `src/entities/Ball.ts` ‚Äî nova geometria e textura
- `src/utils/constants.ts` ‚Äî novo BALL_RADIUS

---

### 2.4 Saque Direto para Oponentes

**Problema:** Saque vai para o meio da quadra, deveria ir direto para o lado advers√°rio.

**Solu√ß√£o:** Calcular trajet√≥ria do saque para cair no lado dos oponentes.

**Comportamento esperado:**

```
                    ANTES                           DEPOIS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         OPONENTES         ‚îÇ     ‚îÇ         OPONENTES         ‚îÇ
‚îÇ    [NPC1]    [NPC2]       ‚îÇ     ‚îÇ    [NPC1]    [NPC2]       ‚îÇ
‚îÇ                           ‚îÇ     ‚îÇ         ‚Üì                 ‚îÇ
‚îÇ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêREDE‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÇ     ‚îÇ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêREDE‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÇ
‚îÇ              ‚Üì            ‚îÇ     ‚îÇ                           ‚îÇ
‚îÇ    [VOC√ä]    [NPC3]       ‚îÇ     ‚îÇ    [VOC√ä]    [NPC3]       ‚îÇ
‚îÇ         ‚öΩ SACADOR        ‚îÇ     ‚îÇ              ‚öΩ SACADOR    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  Bola cai no meio (ruim)           Bola vai direto pros 
                                    oponentes (correto)
```

**Implementa√ß√£o:**

```typescript
// ServeSystem.ts
public executeServe() {
  // Dire√ß√£o: SEMPRE para o lado advers√°rio
  const targetZ = this.servingTeam === "player"
    ? -GAME_CONFIG.COURT_LENGTH / 4  // Meio do lado advers√°rio
    : GAME_CONFIG.COURT_LENGTH / 4;

  // Varia√ß√£o lateral aleat√≥ria (n√£o previs√≠vel)
  const targetX = (Math.random() - 0.5) * GAME_CONFIG.COURT_WIDTH * 0.6;

  // Calcular velocidade para atingir o alvo
  const ballPos = this.ball.getPosition();
  const dx = targetX - ballPos.x;
  const dz = targetZ - ballPos.z;

  // Tempo de voo desejado (~1.5 segundos)
  const flightTime = 1.5;

  // Velocidade horizontal
  const vx = dx / flightTime;
  const vz = dz / flightTime;

  // Velocidade vertical (considerando gravidade)
  // y = y0 + vy*t + 0.5*g*t¬≤
  // Para atingir altura m√°xima de ~4m
  const maxHeight = 4;
  const vy = Math.sqrt(2 * Math.abs(GAME_CONFIG.GRAVITY) * maxHeight);

  this.ball.setVelocity(new THREE.Vector3(vx, vy, vz));
  this.isServing = false;
}
```

**Arquivos afetados:**

- `src/systems/ServeSystem.ts` ‚Äî c√°lculo de trajet√≥ria

---

### 2.5 Saque do Lado Correto

**Problema:** Sacador se posiciona no centro, deveria estar na lateral do seu lado.

**Solu√ß√£o:** Posicionar sacador no canto da linha de fundo do lado que saca.

**Posicionamento correto:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  REDE                    ‚îÇ
‚îÇ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    [NPC 1]              [NPC 2]         ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    [VOC√ä]               [NPC 3]         ‚îÇ
‚îÇ                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                          [SACADOR] ‚öΩ
                             ‚îÇ
                        (fora da quadra,
                         canto direito)
```

**Implementa√ß√£o:**

```typescript
// ServeSystem.ts
public startServe(team: "player" | "opponent") {
  this.servingTeam = team;
  this.isServing = true;

  // Selecionar NPC que vai sacar
  this.serverNPC = this.getServerNPC(team);

  // Posicionar sacador no CANTO da linha de fundo
  const serveZ = team === "player"
    ? GAME_CONFIG.COURT_LENGTH / 2 + 1.5  // Atr√°s da linha do jogador
    : -GAME_CONFIG.COURT_LENGTH / 2 - 1.5; // Atr√°s da linha do oponente

  // Lado aleat√≥rio (esquerda ou direita)
  const side = Math.random() > 0.5 ? 1 : -1;
  const serveX = side * (GAME_CONFIG.COURT_WIDTH / 2 - 1);

  this.serverNPC.setPosition(serveX, serveZ);

  // Posicionar bola no ch√£o em frente ao sacador
  const ballZ = serveZ - Math.sign(serveZ) * 0.5;
  this.ball.reset(serveX, GAME_CONFIG.BALL_RADIUS + 0.1, ballZ);
}
```

**Arquivos afetados:**

- `src/systems/ServeSystem.ts` ‚Äî posicionamento lateral

---

## 3. Checkpoints de Implementa√ß√£o

### CP-01 ‚Äî Regra de Toques Correta

**Goal:** Implementar altern√¢ncia obrigat√≥ria de toques

**Tasks:**

```bash
- Adicionar ID √∫nico para cada jogador (Player e NPC)
- Modificar ScoreSystem para rastrear √∫ltimo jogador que tocou
- Detectar falta: mesmo jogador tocou 2x seguidas
- Detectar falta: mais de 3 toques
- Mostrar feedback visual de falta
- Testar cen√°rios: 1, 2, 3 toques v√°lidos
- Testar cen√°rio: toque duplo (falta)
- Testar cen√°rio: 4 toques (falta)
```

**Success Criteria:**

- N√£o √© poss√≠vel tocar 2x seguidas com mesmo jogador
- M√°ximo 3 toques por time
- Falta √© detectada e ponto marcado

**Commit:** `feat: implement proper touch alternation rules`

---

### CP-02 ‚Äî Controle de For√ßa e Dire√ß√£o

**Goal:** Jogador controla for√ßa e dire√ß√£o do chute/cabeceio

**Tasks:**

```bash
- Criar classe PowerMeter (oscila 0-1-0)
- Criar classe DirectionControl (arrastar para mirar)
- Criar UI do medidor de for√ßa (barra visual)
- Criar indicador de dire√ß√£o 3D (seta)
- Modificar TouchControls: segurar = ativar controle
- Modificar Player: usar for√ßa e dire√ß√£o vari√°veis
- Testar em mobile
- Ajustar sensibilidade
```

**Success Criteria:**

- Segurar bot√£o mostra controles de mira
- Arrastar muda dire√ß√£o
- Barra de for√ßa oscila visivelmente
- Soltar executa a√ß√£o com for√ßa/dire√ß√£o escolhidas
- Chutes fracos vs fortes t√™m diferen√ßa clara

**Commit:** `feat: add power and direction controls for actions`

---

### CP-03 ‚Äî Nova Bola Mikasa

**Goal:** Bola com visual de futev√¥lei profissional

**Tasks:**

```bash
- Aumentar BALL_RADIUS para 0.45
- Criar textura com padr√£o pent√°gono/hex√°gono
- OU usar IcosahedronGeometry com cores alternadas
- Adicionar costuras/linhas entre formas
- Testar visual em diferentes √¢ngulos
- Ajustar f√≠sica se necess√°rio
```

**Success Criteria:**

- Bola claramente maior e mais vis√≠vel
- Padr√£o amarelo/preto estilo bola profissional
- Visual agrad√°vel em movimento

**Commit:** `feat: new Mikasa-style ball design`

---

### CP-04 ‚Äî Saque para Oponentes + Posi√ß√£o Lateral

**Goal:** Saque realista de futev√¥lei

**Tasks:**

```bash
- Modificar posicionamento do sacador (lateral, n√£o central)
- Calcular trajet√≥ria para cair no lado advers√°rio
- Adicionar varia√ß√£o aleat√≥ria no alvo
- Testar altura do arco (deve passar rede)
- Testar que bola cai em √°rea v√°lida
```

**Success Criteria:**

- Sacador no canto da linha de fundo
- Bola vai por cima da rede
- Bola cai no lado advers√°rio
- Varia√ß√£o suficiente para n√£o ser previs√≠vel

**Commit:** `feat: proper serve positioning and trajectory`

---

## 4. Ordem de Prioridade

```
1. CP-01 (Regra de Toques)   ‚Üê Cr√≠tico para gameplay correto
2. CP-04 (Saque Correto)     ‚Üê Importante para fluxo do jogo
3. CP-02 (For√ßa/Dire√ß√£o)     ‚Üê Melhora muito a jogabilidade
4. CP-03 (Bola Mikasa)       ‚Üê Visual polish
```

---

## 5. Riscos

| Risco                               | Impacto             | Mitiga√ß√£o                              |
| ----------------------------------- | ------------------- | -------------------------------------- |
| Medidor de for√ßa muito r√°pido/lento | Frustrante          | Parametrizar velocidade, testar muito  |
| Indicador de dire√ß√£o confuso        | Chutes errados      | Feedback visual claro, preview         |
| Regra de toques bugada              | Jogo injusto        | Muitos testes de cen√°rios              |
| Saque muito forte/fraco             | Gameplay quebrado   | Ajustar par√¢metros de f√≠sica           |
| Textura da bola n√£o mapeando bem    | Visual feio         | Usar geometria ao inv√©s de UV mapping  |

---

## 6. Testes Recomendados

### Regra de Toques

- [ ] Jogador toca ‚Üí Parceiro toca ‚Üí Jogador ataca (3 toques OK)
- [ ] Jogador toca ‚Üí Jogador toca novamente (FALTA)
- [ ] Parceiro toca 2x seguidas (FALTA)
- [ ] 4 toques no time (FALTA)
- [ ] 1 toque direto (OK)
- [ ] 2 toques (OK)

### Controle de For√ßa/Dire√ß√£o

- [ ] Toque r√°pido = chute default (sem mira)
- [ ] Segurar mostra indicadores
- [ ] Arrastar muda dire√ß√£o visualmente
- [ ] Barra de for√ßa oscila
- [ ] Soltar executa com for√ßa correta
- [ ] For√ßa 100% = chute muito forte
- [ ] For√ßa 20% = chute fraco

### Saque

- [ ] Sacador aparece no canto (n√£o centro)
- [ ] Bola vai para lado advers√°rio
- [ ] Bola passa por cima da rede
- [ ] Saque tem varia√ß√£o lateral

---

## 7. Comando Ralph Loop

Para executar este PRD:

```bash
/ralph-loop:ralph-loop "Leia o PRD em ./prds/v0.3-game-improvements.md. Implemente as melhorias do JunVolei seguindo os checkpoints em ordem (CP-01 a CP-04). Para cada checkpoint: 1) Implemente o c√≥digo necess√°rio 2) Teste manualmente se funciona 3) Fa√ßa commit. Priorize CP-01 (regra de toques) pois √© cr√≠tico para gameplay. Ao completar todos os checkpoints, emita <promise>COMPLETE</promise>" --completion-promise "COMPLETE" --max-iterations 60
```

---

**√öltima atualiza√ß√£o:** Janeiro 2026  
**Autor:** Feedback de playtesting üèê‚öΩ
