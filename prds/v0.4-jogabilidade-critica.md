# PRD v0.4 ‚Äî Corre√ß√µes Cr√≠ticas de Jogabilidade

**Produto:** Simulador de Futev√¥lei 3D no Browser  
**Codinome:** JunVolei  
**Vers√£o:** v0.4 (Corre√ß√µes Cr√≠ticas de Jogabilidade)  
**Status:** PRONTO PARA IMPLEMENTA√á√ÉO  
**Baseado em:** Feedback de playtesting v0.3

---

## 1. Resumo do Problema

O jogo est√° **injog√°vel** devido a dois problemas cr√≠ticos:

| #   | Problema                      | Severidade | Impacto                                  |
| --- | ----------------------------- | ---------- | ---------------------------------------- |
| 1   | Saque imposs√≠vel de realizar  | CR√çTICO    | Jogador n√£o consegue iniciar uma partida |
| 2   | Oponente nunca devolve a bola | CR√çTICO    | N√£o h√° rally, jogo n√£o funciona          |

Al√©m disso, este PRD inclui um **loop de testes de jogabilidade** obrigat√≥rio para garantir que o jogo funcione antes de considerar qualquer feature completa.

---

## 2. An√°lise dos Problemas

### 2.1 Problema: Saque Imposs√≠vel

**Sintomas reportados:**

- Jogador n√£o consegue executar o saque
- Sistema de saque muito complexo ou bugado
- Bola n√£o responde aos comandos durante o saque

**Causas prov√°veis:**

1. **Timing muito restrito:** O medidor de for√ßa (PowerMeter) pode estar oscilando r√°pido demais
2. **Controles confusos:** Sistema de dire√ß√£o + for√ßa pode estar conflitando
3. **F√≠sica quebrada:** Bola pode n√£o estar respondendo ao impulso do saque
4. **Estado do jogo travado:** Game state pode n√£o transicionar corretamente de "serving" para "playing"
5. **NPC n√£o executa o saque:** ServeSystem pode estar esperando input do jogador quando deveria ser autom√°tico

**Investiga√ß√£o necess√°ria:**

```
Perguntas a responder:
‚îú‚îÄ‚îÄ O saque √© feito pelo NPC ou pelo jogador?
‚îú‚îÄ‚îÄ O jogador precisa fazer algo para o saque acontecer?
‚îú‚îÄ‚îÄ A bola responde ao impulso aplicado?
‚îú‚îÄ‚îÄ O game state muda de "serving" para "playing"?
‚îî‚îÄ‚îÄ H√° erros no console durante o saque?
```

---

### 2.2 Problema: Oponente N√£o Devolve a Bola

**Sintomas reportados:**

- NPCs advers√°rios n√£o atacam para o lado do jogador
- A bola fica do lado dos oponentes at√© cair
- N√£o h√° troca de bola (rally n√£o acontece)

**Causas prov√°veis:**

1. **IA n√£o detecta que deve atacar:** L√≥gica de decis√£o do NPC n√£o identifica momento de ataque
2. **Dire√ß√£o do ataque errada:** NPC ataca mas a bola n√£o vai para o outro lado
3. **NPC n√£o alcan√ßa a bola:** Velocidade/rea√ß√£o do NPC muito lenta
4. **Contagem de toques bugada:** NPC pensa que ainda pode passar para parceiro
5. **For√ßa do chute insuficiente:** NPC chuta mas bola n√£o tem for√ßa para passar a rede

**Investiga√ß√£o necess√°ria:**

```
Perguntas a responder:
‚îú‚îÄ‚îÄ O NPC detecta quando a bola est√° no seu lado?
‚îú‚îÄ‚îÄ O NPC decide corretamente entre defender/passar/atacar?
‚îú‚îÄ‚îÄ Quando o NPC ataca, a dire√ß√£o est√° correta (Z negativo)?
‚îú‚îÄ‚îÄ A for√ßa do chute √© suficiente para passar a rede?
‚îú‚îÄ‚îÄ O NPC est√° respeitando a regra de 3 toques?
‚îî‚îÄ‚îÄ O √∫ltimo toque est√° resultando em ataque?
```

---

## 3. Solu√ß√µes Propostas

### 3.1 Solu√ß√£o: Simplificar o Saque

**Filosofia:** O saque deve "simplesmente funcionar" sem exigir habilidade especial do jogador.

**Novo comportamento do saque:**

```
FLUXO SIMPLIFICADO DO SAQUE:

1. Ponto marcado
      ‚îÇ
      ‚ñº
2. Pausa de 1.5s (mostrar placar)
      ‚îÇ
      ‚ñº
3. NPC sacador se posiciona automaticamente
      ‚îÇ
      ‚ñº
4. Bola aparece no ar em frente ao sacador
      ‚îÇ
      ‚ñº
5. NPC SACA AUTOMATICAMENTE ap√≥s 1s
      ‚îÇ
      ‚ñº
6. Bola vai para o lado advers√°rio
      ‚îÇ
      ‚ñº
7. Estado muda para "playing"
      ‚îÇ
      ‚ñº
8. Rally continua normalmente
```

**Mudan√ßas principais:**

1. **Saque autom√°tico do NPC:** Remover qualquer necessidade de input do jogador
2. **Bola j√° posicionada no ar:** Em vez de no ch√£o (evita f√≠sica complexa)
3. **Trajet√≥ria garantida:** C√°lculo simplificado para sempre passar a rede
4. **Feedback visual claro:** Indicador de "Saque em X segundos..."

**Implementa√ß√£o:**

```typescript
// ServeSystem.ts - SIMPLIFICADO
export class ServeSystem {
  private serveState: "waiting" | "positioning" | "ready" | "serving" =
    "waiting";
  private serveTimer: number = 0;
  private readonly POSITION_TIME = 1000; // 1s para posicionar
  private readonly SERVE_DELAY = 1000; // 1s antes de sacar

  public startServe(team: "player" | "opponent") {
    this.servingTeam = team;
    this.serveState = "positioning";
    this.serveTimer = 0;

    // Selecionar NPC sacador
    this.serverNPC = this.getServerNPC(team);

    // Posi√ß√£o de saque (lateral)
    const side = Math.random() > 0.5 ? 1 : -1;
    const serveX = side * (GAME_CONFIG.COURT_WIDTH / 3);
    const serveZ =
      team === "player"
        ? GAME_CONFIG.COURT_LENGTH / 2 + 1
        : -GAME_CONFIG.COURT_LENGTH / 2 - 1;

    this.serverNPC.setPosition(serveX, serveZ);
  }

  public update(deltaTime: number) {
    this.serveTimer += deltaTime;

    switch (this.serveState) {
      case "positioning":
        // Esperar NPC chegar na posi√ß√£o
        if (this.serveTimer > this.POSITION_TIME) {
          this.prepareServe();
          this.serveState = "ready";
          this.serveTimer = 0;
        }
        break;

      case "ready":
        // Bola no ar, esperando para sacar
        if (this.serveTimer > this.SERVE_DELAY) {
          this.executeServe();
          this.serveState = "waiting";
        }
        break;
    }
  }

  private prepareServe() {
    const serverPos = this.serverNPC.getPosition();

    // Bola j√° no ar (altura de saque) em frente ao sacador
    const ballX = serverPos.x;
    const ballY = 1.5; // Altura confort√°vel para "chutar"
    const ballZ = serverPos.z - Math.sign(serverPos.z) * 0.5;

    this.ball.reset(ballX, ballY, ballZ);
    this.ball.setVelocity(new THREE.Vector3(0, 0, 0)); // Parada no ar
  }

  private executeServe() {
    // GARANTIR que a bola vai para o lado advers√°rio
    const targetZ =
      this.servingTeam === "player"
        ? -GAME_CONFIG.COURT_LENGTH / 4 // Meio do lado advers√°rio
        : GAME_CONFIG.COURT_LENGTH / 4;

    // Varia√ß√£o lateral
    const targetX = (Math.random() - 0.5) * GAME_CONFIG.COURT_WIDTH * 0.5;

    const ballPos = this.ball.getPosition();

    // Velocidade calculada para atingir o alvo
    const dx = targetX - ballPos.x;
    const dz = targetZ - ballPos.z;
    const distance = Math.sqrt(dx * dx + dz * dz);

    // Velocidade horizontal (ajustada para dist√¢ncia)
    const speed = Math.min(12, 8 + distance * 0.5);
    const direction = new THREE.Vector3(dx, 0, dz).normalize();

    // Velocidade vertical para arco sobre a rede
    const vy = 6; // For√ßa vertical para arco bonito

    const velocity = direction.multiplyScalar(speed);
    velocity.y = vy;

    this.ball.setVelocity(velocity);

    // Notificar que rally come√ßou
    this.onServeComplete();
  }
}
```

---

### 3.2 Solu√ß√£o: NPC Deve Atacar para o Outro Lado

**Filosofia:** Ap√≥s receber a bola, o time advers√°rio DEVE devolver para o lado do jogador.

**Comportamento esperado do NPC:**

```
√ÅRVORE DE DECIS√ÉO DO NPC:

Bola est√° vindo pro meu lado?
        ‚îÇ
        ‚îú‚îÄ‚îÄ N√ÉO ‚Üí Posicionar-se defensivamente
        ‚îÇ
        ‚îî‚îÄ‚îÄ SIM ‚Üí Bola est√° ao meu alcance?
                      ‚îÇ
                      ‚îú‚îÄ‚îÄ N√ÉO ‚Üí Mover em dire√ß√£o √† bola
                      ‚îÇ
                      ‚îî‚îÄ‚îÄ SIM ‚Üí Este √© o 3¬∫ toque do meu time?
                                    ‚îÇ
                                    ‚îú‚îÄ‚îÄ SIM ‚Üí ATACAR (obrigat√≥rio)
                                    ‚îÇ
                                    ‚îî‚îÄ‚îÄ N√ÉO ‚Üí Parceiro est√° em posi√ß√£o melhor?
                                                    ‚îÇ
                                                    ‚îú‚îÄ‚îÄ SIM ‚Üí Passar para parceiro
                                                    ‚îÇ
                                                    ‚îî‚îÄ‚îÄ N√ÉO ‚Üí Atacar ou passar
```

**Mudan√ßas cr√≠ticas:**

1. **For√ßar ataque no 3¬∫ toque:** SEMPRE atacar (devolver) no terceiro toque
2. **Dire√ß√£o do ataque correta:** Z sempre aponta para o lado advers√°rio
3. **For√ßa suficiente:** Garantir que bola passa a rede
4. **Decis√£o mais agressiva:** NPCs devem preferir atacar a ficar passando

**Implementa√ß√£o - L√≥gica de Ataque:**

```typescript
// NPC.ts - L√≥gica de decis√£o melhorada
export class NPC {
  private team: "player" | "opponent";

  public update(deltaTime: number) {
    const ballPos = this.ball.getPosition();
    const myPos = this.mesh.position;

    // Verificar se bola est√° do meu lado
    const ballInMySide = this.isBallInMySide(ballPos);

    if (!ballInMySide) {
      // Posicionar defensivamente
      this.moveToDefensivePosition();
      return;
    }

    // Bola est√° do meu lado - preciso reagir
    const distanceToBall = this.distanceTo(ballPos);

    if (distanceToBall > this.reachDistance) {
      // Mover em dire√ß√£o √† bola
      this.moveTowards(ballPos);
      return;
    }

    // Estou perto o suficiente para tocar
    this.decideAction();
  }

  private decideAction() {
    const touchCount = this.scoreSystem.getTeamTouchCount(this.team);
    const canITouch = this.scoreSystem.canPlayerTouch(this.id);

    if (!canITouch) {
      // N√£o posso tocar (regra de altern√¢ncia) - deixar parceiro
      return;
    }

    // REGRA CR√çTICA: No 3¬∫ toque, DEVE atacar
    if (touchCount >= 2) {
      this.attack();
      return;
    }

    // 1¬∫ ou 2¬∫ toque - decidir entre passar ou atacar
    const partnerInGoodPosition = this.isPartnerInGoodPosition();
    const goodAttackOpportunity = this.isGoodAttackOpportunity();

    if (touchCount === 0 && partnerInGoodPosition) {
      // Primeiro toque - levantar para parceiro
      this.passToPartner();
    } else if (goodAttackOpportunity || touchCount >= 1) {
      // Boa oportunidade ou j√° √© 2¬∫ toque - atacar
      this.attack();
    } else {
      this.passToPartner();
    }
  }

  private attack() {
    // CR√çTICO: Dire√ß√£o SEMPRE para o lado advers√°rio
    const attackDirection = this.getAttackDirection();

    // For√ßa suficiente para passar a rede
    const attackForce = 10 + Math.random() * 5; // 10-15 de for√ßa

    // Aplicar impulso na bola
    const velocity = attackDirection.multiplyScalar(attackForce);
    velocity.y = 5 + Math.random() * 3; // Arco para passar rede

    this.ball.setVelocity(velocity);
    this.scoreSystem.registerTouch(this.id, this.team);

    console.log(`NPC ${this.id} ATACOU para o lado advers√°rio`);
  }

  private getAttackDirection(): THREE.Vector3 {
    // Dire√ß√£o base: para o lado advers√°rio
    const baseZ = this.team === "player" ? -1 : 1;

    // Varia√ß√£o lateral para n√£o ser previs√≠vel
    const randomX = (Math.random() - 0.5) * 0.6;

    return new THREE.Vector3(randomX, 0, baseZ).normalize();
  }

  private passToPartner() {
    const partnerPos = this.getPartner().getPosition();
    const direction = partnerPos.clone().sub(this.mesh.position).normalize();

    // Passe leve
    const passForce = 4 + Math.random() * 2;
    const velocity = direction.multiplyScalar(passForce);
    velocity.y = 4; // Arco alto para dar tempo

    this.ball.setVelocity(velocity);
    this.scoreSystem.registerTouch(this.id, this.team);

    console.log(`NPC ${this.id} passou para parceiro`);
  }

  private isBallInMySide(ballPos: THREE.Vector3): boolean {
    if (this.team === "player") {
      return ballPos.z > 0; // Lado positivo Z
    } else {
      return ballPos.z < 0; // Lado negativo Z
    }
  }
}
```

**Implementa√ß√£o - Garantir que ataque passa a rede:**

```typescript
// Verifica√ß√£o de altura m√≠nima
private validateAttackTrajectory(velocity: THREE.Vector3): boolean {
  // Simular trajet√≥ria simplificada
  const startPos = this.ball.getPosition();
  const netZ = 0; // Rede est√° em Z = 0

  // Tempo para chegar na rede
  const timeToNet = Math.abs(netZ - startPos.z) / Math.abs(velocity.z);

  // Altura na rede
  const heightAtNet = startPos.y + velocity.y * timeToNet +
                      0.5 * GAME_CONFIG.GRAVITY * timeToNet * timeToNet;

  // Deve estar acima da rede
  return heightAtNet > GAME_CONFIG.NET_HEIGHT + 0.2;
}

private adjustVelocityForNet(velocity: THREE.Vector3): THREE.Vector3 {
  // Se trajet√≥ria n√£o passa a rede, aumentar componente Y
  while (!this.validateAttackTrajectory(velocity) && velocity.y < 15) {
    velocity.y += 0.5;
  }
  return velocity;
}
```

---

## 4. Loop de Testes de Jogabilidade

**OBRIGAT√ìRIO:** Todo checkpoint deve passar pelo loop de testes antes de ser considerado completo.

### 4.1 Estrutura do Loop de Testes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    LOOP DE TESTES DE JOGABILIDADE               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ   ‚îÇIMPLEMENTAR‚îÇ ‚Üí ‚îÇ  TESTAR  ‚îÇ ‚Üí ‚îÇ FUNCIONA?‚îÇ ‚Üí ‚îÇ  COMMIT  ‚îÇ  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                         ‚Üë               ‚îÇ                       ‚îÇ
‚îÇ                         ‚îÇ               ‚îÇ N√ÉO                   ‚îÇ
‚îÇ                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 4.2 Checkpoints de Teste

Cada checkpoint tem testes OBRIGAT√ìRIOS que devem passar:

---

#### TEST-01: Jogo Inicia Corretamente

```
CHECKLIST:
‚ñ° Jogo carrega sem erros no console
‚ñ° Menu inicial aparece
‚ñ° Bot√£o "Jogar" funciona
‚ñ° Quadra e jogadores aparecem
‚ñ° Bola est√° vis√≠vel
```

**Como testar:**

1. Abrir o jogo no browser
2. Verificar console (F12) - n√£o deve haver erros
3. Clicar em "Jogar"
4. Confirmar que todos elementos visuais est√£o presentes

---

#### TEST-02: Saque Funciona

```
CHECKLIST:
‚ñ° Ap√≥s clicar "Jogar", saque acontece automaticamente
‚ñ° NPC sacador se posiciona corretamente
‚ñ° Bola aparece na posi√ß√£o correta
‚ñ° Ap√≥s delay, bola √© sacada
‚ñ° Bola passa por cima da rede
‚ñ° Bola cai no lado advers√°rio
‚ñ° Estado muda para "playing" (jogador pode se mover)
```

**Como testar:**

1. Iniciar partida
2. N√ÉO tocar em nada - observar saque autom√°tico
3. Verificar se bola cruza a rede
4. Verificar se jogador pode se mover ap√≥s saque

**Crit√©rio de sucesso:** 5 saques consecutivos bem-sucedidos

---

#### TEST-03: Oponente Devolve a Bola

```
CHECKLIST:
‚ñ° Ap√≥s saque, NPC oponente se move em dire√ß√£o √† bola
‚ñ° NPC oponente toca na bola
‚ñ° Ap√≥s 1-3 toques, bola vai para o lado do jogador
‚ñ° Bola passa por cima da rede
‚ñ° Bola cai do lado do jogador (ou √© defendida)
‚ñ° Rally continua (bola vai e volta)
```

**Como testar:**

1. Iniciar partida
2. Deixar saque acontecer
3. N√ÉO fazer nada - observar NPCs
4. Verificar se bola volta para seu lado
5. Repetir 5 vezes

**Crit√©rio de sucesso:** Em 5 tentativas, bola deve voltar pelo menos 4 vezes

---

#### TEST-04: Rally Completo

```
CHECKLIST:
‚ñ° Bola vai para lado advers√°rio (saque ou ataque)
‚ñ° Advers√°rios devolvem
‚ñ° Bola volta para seu lado
‚ñ° Voc√™ ou seu NPC aliado devolvem
‚ñ° Ciclo se repete pelo menos 3 vezes
‚ñ° Ponto √© marcado quando bola cai
‚ñ° Placar atualiza corretamente
```

**Como testar:**

1. Iniciar partida
2. Tentar manter rally ativo
3. Contar quantas vezes bola cruza a rede
4. Verificar se ponto √© marcado corretamente

**Crit√©rio de sucesso:** Rally de 3+ trocas pelo menos 1 vez em 5 tentativas

---

#### TEST-05: Controles Funcionam

```
CHECKLIST (Desktop):
‚ñ° WASD movem o jogador
‚ñ° Espa√ßo ou clique chuta a bola
‚ñ° Jogador n√£o atravessa paredes/rede
‚ñ° C√¢mera segue o jogador

CHECKLIST (Mobile - se aplic√°vel):
‚ñ° Joystick virtual aparece
‚ñ° Arrastar joystick move jogador
‚ñ° Bot√µes de a√ß√£o funcionam
```

**Como testar:**

1. Mover jogador em todas dire√ß√µes
2. Ir at√© a bola e chutar
3. Verificar se bola responde
4. Testar limites da quadra

---

#### TEST-06: Partida Completa

```
CHECKLIST:
‚ñ° Poss√≠vel jogar do in√≠cio ao fim (12 pontos)
‚ñ° Placar funciona corretamente
‚ñ° Altern√¢ncia de saque funciona
‚ñ° Tela de vit√≥ria/derrota aparece
‚ñ° Bot√£o "Jogar Novamente" funciona
‚ñ° N√£o h√° crashes durante toda partida
```

**Como testar:**

1. Jogar partida completa at√© 12 pontos
2. Verificar se todos estados funcionam
3. Reiniciar e jogar novamente

---

### 4.3 Protocolo de Teste Automatizado (Playwright)

Para testes automatizados, criar arquivo `tests/gameplay.spec.ts`:

```typescript
// tests/gameplay.spec.ts
import { test, expect } from "@playwright/test";

test.describe("JunVolei Gameplay Tests", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("http://localhost:5173");
    // Esperar jogo carregar
    await page.waitForSelector("#game-container", { timeout: 5000 });
  });

  test("TEST-01: Jogo inicia sem erros", async ({ page }) => {
    // Verificar que n√£o h√° erros no console
    const errors: string[] = [];
    page.on("console", (msg) => {
      if (msg.type() === "error") errors.push(msg.text());
    });

    await page.waitForTimeout(2000);
    expect(errors).toHaveLength(0);

    // Verificar elementos visuais
    const canvas = await page.$("canvas");
    expect(canvas).not.toBeNull();
  });

  test("TEST-02: Menu e in√≠cio de partida", async ({ page }) => {
    // Bot√£o jogar deve existir
    const playButton = await page.waitForSelector("#play-button", {
      timeout: 5000,
    });
    expect(playButton).not.toBeNull();

    // Clicar para jogar
    await playButton.click();

    // Aguardar jogo iniciar (saque acontecer)
    await page.waitForTimeout(3000);

    // Verificar que estado mudou (algum indicador de jogo ativo)
    // Isso depende da implementa√ß√£o espec√≠fica do HUD
  });

  test("TEST-03: Saque acontece automaticamente", async ({ page }) => {
    await page.click("#play-button");

    // Esperar saque (2-3 segundos)
    await page.waitForTimeout(4000);

    // Verificar posi√ß√£o da bola (deve ter cruzado Z=0)
    // Isso requer expor estado do jogo para testes
    // Alternativa: verificar logs no console

    const logs: string[] = [];
    page.on("console", (msg) => logs.push(msg.text()));

    await page.waitForTimeout(2000);

    // Deve haver log de saque executado
    expect(
      logs.some((log) => log.includes("saque") || log.includes("serve"))
    ).toBeTruthy();
  });

  test("TEST-04: NPCs respondem √† bola", async ({ page }) => {
    await page.click("#play-button");
    await page.waitForTimeout(5000); // Saque + tempo de rea√ß√£o

    // Verificar logs de NPCs tocando na bola
    const logs: string[] = [];
    page.on("console", (msg) => logs.push(msg.text()));

    await page.waitForTimeout(5000);

    // Deve haver logs de toques/ataques
    const hasNPCActivity = logs.some(
      (log) =>
        log.includes("NPC") &&
        (log.includes("tocou") ||
          log.includes("atacou") ||
          log.includes("passed"))
    );
    expect(hasNPCActivity).toBeTruthy();
  });
});
```

---

## 5. Checkpoints de Implementa√ß√£o

### CP-01 ‚Äî Diagn√≥stico e Log de Debug

**Goal:** Entender exatamente o que est√° acontecendo no jogo

**Tasks:**

```bash
- Adicionar logs detalhados em ServeSystem (todos estados)
- Adicionar logs em NPC (todas decis√µes)
- Adicionar logs em ScoreSystem (todos toques)
- Rodar jogo e observar console
- Documentar problemas encontrados
```

**Success Criteria:**

- Console mostra claramente o fluxo do saque
- Console mostra decis√µes dos NPCs
- Problemas identificados e documentados

**Commit:** `debug: add comprehensive logging for serve and NPC behavior`

---

### CP-02 ‚Äî Corrigir Saque Autom√°tico

**Goal:** Saque funciona 100% das vezes sem input do jogador

**Tasks:**

```bash
- Simplificar ServeSystem (remover complexidade)
- Bola j√° posicionada no ar
- NPC saca automaticamente ap√≥s delay
- Garantir trajet√≥ria passa a rede
- Testar 10 saques consecutivos
```

**Testes obrigat√≥rios (TEST-02):**

- [ ] 5 saques consecutivos bem-sucedidos
- [ ] Bola passa rede em todos
- [ ] Estado muda para "playing"

**Success Criteria:**

- Saque acontece automaticamente
- Bola sempre passa a rede
- Bola sempre cai no lado advers√°rio

**Commit:** `fix: serve now works automatically and reliably`

---

### CP-03 ‚Äî Corrigir NPC Attack Direction

**Goal:** NPC oponente SEMPRE ataca para o lado do jogador

**Tasks:**

```bash
- Verificar l√≥gica de getAttackDirection()
- Garantir Z correto baseado no time
- Adicionar for√ßa m√≠nima para passar rede
- For√ßar ataque no 3¬∫ toque (obrigat√≥rio)
- Testar 10 rallies
```

**Testes obrigat√≥rios (TEST-03):**

- [ ] NPC se move em dire√ß√£o √† bola
- [ ] NPC toca na bola
- [ ] Bola vai para lado do jogador em 4/5 tentativas

**Success Criteria:**

- NPC ataca para o lado correto
- Bola passa a rede
- Rally acontece

**Commit:** `fix: NPC now attacks toward opponent's side correctly`

---

### CP-04 ‚Äî Garantir Rally Funcional

**Goal:** Jogo permite rally de m√∫ltiplas trocas

**Tasks:**

```bash
- Verificar que NPC aliado tamb√©m funciona
- Verificar altern√¢ncia de toques
- Ajustar velocidade/rea√ß√£o dos NPCs
- Testar partida completa
- Ajustar dificuldade se necess√°rio
```

**Testes obrigat√≥rios (TEST-04):**

- [ ] Rally de 3+ trocas poss√≠vel
- [ ] Pontos marcados corretamente
- [ ] Partida flui naturalmente

**Success Criteria:**

- Rally funciona
- Jogo √© jog√°vel
- Divers√£o b√°sica atingida

**Commit:** `fix: rally system working properly`

---

### CP-05 ‚Äî Testes Automatizados

**Goal:** Testes Playwright garantem regress√µes n√£o ocorram

**Tasks:**

```bash
- Criar tests/gameplay.spec.ts
- Implementar TEST-01 a TEST-06
- Rodar testes e verificar resultados
- Corrigir falhas encontradas
- Integrar testes no workflow
```

**Success Criteria:**

- Todos testes passam
- Testes podem ser rodados com npm test

**Commit:** `test: add Playwright tests for core gameplay`

---

### CP-06 ‚Äî Polish e Ajustes de Jogabilidade

**Goal:** Jogo √© divertido de jogar

**Tasks:**

```bash
- Ajustar velocidade dos NPCs (n√£o muito f√°cil/dif√≠cil)
- Ajustar for√ßa dos chutes
- Ajustar f√≠sica da bola (bounce, etc)
- Testar partida completa 3 vezes
- Coletar feedback e ajustar
```

**Testes obrigat√≥rios (TEST-06):**

- [ ] Partida completa sem crashes
- [ ] Placar funciona
- [ ] Reiniciar funciona

**Success Criteria:**

- Jogo √© jog√°vel e divertido
- N√£o h√° bugs cr√≠ticos
- Partida completa poss√≠vel

**Commit:** `polish: gameplay balance and feel adjustments`

---

## 6. Ordem de Prioridade

```
1. CP-01 (Diagn√≥stico)          ‚Üê Entender o problema
2. CP-02 (Corrigir Saque)       ‚Üê CR√çTICO
3. CP-03 (NPC Attack Direction) ‚Üê CR√çTICO
4. CP-04 (Rally Funcional)      ‚Üê Validar que funciona
5. CP-05 (Testes Playwright)    ‚Üê Garantir qualidade
6. CP-06 (Polish)               ‚Üê Melhorar experi√™ncia
```

---

## 7. Riscos e Mitiga√ß√µes

| Risco                         | Impacto             | Mitiga√ß√£o                               |
| ----------------------------- | ------------------- | --------------------------------------- |
| F√≠sica da bola imprevis√≠vel   | Saque/ataque falham | Simplificar, usar velocidades fixas     |
| IA muito complexa             | Bugs dif√≠ceis       | Simplificar √°rvore de decis√£o           |
| Testes n√£o detectam problemas | Bugs em produ√ß√£o    | Testar manualmente al√©m de automatizado |
| Performance ruim com logs     | Jogo lento          | Remover logs ap√≥s debug                 |

---

## 8. Defini√ß√£o de "Pronto"

O jogo ser√° considerado JOG√ÅVEL quando:

```
CRIT√âRIOS DE ACEITA√á√ÉO:

‚úì Saque funciona automaticamente (100% das vezes)
‚úì NPC advers√°rio devolve a bola (80%+ das vezes)
‚úì Rally de 3+ trocas √© poss√≠vel
‚úì Pontos s√£o marcados corretamente
‚úì Partida completa (12 pontos) √© poss√≠vel
‚úì Todos testes Playwright passam
‚úì Nenhum erro cr√≠tico no console
‚úì Jogador consegue se divertir
```

---

## 9. Comando Ralph Loop

Para executar este PRD:

```bash
/ralph-loop:ralph-loop "Leia o PRD em ./prds/v0.4-jogabilidade-critica.md. IMPORTANTE: Este PRD corrige problemas cr√≠ticos de jogabilidade. Siga os checkpoints em ordem (CP-01 a CP-06). Para CADA checkpoint: 1) Implemente o c√≥digo 2) EXECUTE OS TESTES OBRIGAT√ìRIOS listados no checkpoint 3) S√≥ prossiga se testes passarem 4) Fa√ßa commit. Se um teste falhar, corrija antes de continuar. Use o browser para testar o jogo visualmente. Ao completar todos checkpoints com testes passando, emita <promise>COMPLETE</promise>" --completion-promise "COMPLETE" --max-iterations 80
```

---

## 10. Ap√™ndice: Debug Helpers

### Visualiza√ß√£o de Debug

```typescript
// Adicionar em main.ts para debug visual
const DEBUG = true;

if (DEBUG) {
  // Mostrar dire√ß√£o dos NPCs
  npcs.forEach((npc) => {
    const arrow = new THREE.ArrowHelper(
      npc.getIntendedDirection(),
      npc.getPosition(),
      2,
      0xff0000
    );
    scene.add(arrow);
  });

  // Mostrar trajet√≥ria da bola
  const trajectoryLine = new THREE.Line(
    new THREE.BufferGeometry(),
    new THREE.LineBasicMaterial({ color: 0x00ff00 })
  );
  scene.add(trajectoryLine);

  // Atualizar a cada frame
  function updateDebug() {
    // Predizer pr√≥ximos 2 segundos da bola
    const points = predictBallTrajectory(ball, 2);
    trajectoryLine.geometry.setFromPoints(points);
  }
}
```

### Console Commands para Debug

```typescript
// Expor para console do browser
(window as any).junvolei = {
  forceServe: () => serveSystem.startServe("player"),
  forceBallTo: (x: number, z: number) => ball.reset(x, 2, z),
  logNPCState: () => npcs.forEach((npc) => console.log(npc.getState())),
  setNPCSpeed: (speed: number) => npcs.forEach((npc) => (npc.speed = speed)),
  skipToPoint: (team: "player" | "opponent") => scoreSystem.addPoint(team),
};
```

---

**√öltima atualiza√ß√£o:** Janeiro 2026  
**Autor:** Corre√ß√µes cr√≠ticas para jogo jog√°vel üèêüîß
